## 도입
### 알고리즘의 정당성 증명
문제가 복잡해지면 알고리즘이 문제를 제대로 해결하는지 파악하기 어렵다.
단위 테스트를 이용해 여러 입력에 대해 답을 점검해 볼 수 있지만, 이는 알고리즘이 모든 입력에 대해
정확하게 동작한다는 사실은 증명할 수 없다. 따라서 알고리즘의 정확한 증명을 위해서는 각종 수학적인
기법이 동원되어야 한다.

## 수학적 귀납법과 반복문 불변식
### 수학적 귀납법
수학적 귀납법(mathematical induction)은 반복적인 구조를 갖는 명제들을 증명하는 데 유용하게 사용되는
증명 기법이다. 귀납법 증명은 크게 세 단계로 나뉜다.
* 단계 나누기: 증명하고 싶은 사실을 여러 단계로 나눈다.
* 첫 단계 증명: 그중 첫 단계에서 증명하고 싶은 내용이 성립함을 보인다.
* 귀납 증명: N 번째 단계에서 성립한다고 가정하고, N+1 번째 단계에서도 성립함을 보인다.

### 반복문 불변식
귀납법은 알고리즘 정당성을 증명할 때 가장 유용하게 사용되는 기법이다. 왜냐면 대부분 알고리즘은
어떠한 형태든 반복적인 요소를 가지고 있기 때문이다. 귀납법은 이런 알고리즘들이 옳은 답을 계산함을
보이기 위해 알고리즘의 각 단계가 정답으로 가는 길 위에 있음을 보이고, 결과적으로 알고리즘의 답이
옳음을 보인다.

귀납법을 이용해 알고리즘의 정당성을 증명할 땐 반복문 불변식(loop in-variant)이라는 개념이
유용하게 쓰인다. 

> 반복문 불변식이란, 반복문의 내용이 한 번 실행될 때마다 중간 결과가 우리가 원하는
답으로 가는 길 위에 잘 있는지를 명시하는 조건이다.

불변식을 이용하면 반복문의 정당성을 다음과 같이 증명할 수 있다.

1. 반복문 진입시에 불변식이 성립함을 보인다.
2. 반복문 내용이 불변식을 깨뜨리지 않음을 보인다. 다르게 말하면, 반복문 내용이 시작할 때 불변식이
성립했다면 내용이 끝날 때도 불변식이 항상 성립함을 보인다.
3. 반복문 종료시에 불변식이 성립하면 항상 우리가 정답을 구했음을 보인다.

1, 2번을 증명했다면 수학적 귀납법을 이용해 이들은 반복문이 종료할 때까지 항상 이 불변식이 성립함을
보일 수 있다. 예를 들어 while 문에서 실제 불변식이 성립함을 보여야 하는 위치는 다음과 같다.
```
// (*) 불변식은 여기에서 성립해야 한다.
while (어떤 조건) {
    // 반복문 내용의 시작
    ..
    // 반복문 내용의 끝
    // (**) 불변식은 여기에서도 성립해야 한다.
}
```

### 반복문 불변식 예제: 이진 탐색
```
// 필수 조건: A는 오름차순으로 정렬되어 있다
// 결과: A[i-1] < x <= A[i] 인 i를 반환한다.
// 이때 A[-1] = 음의 무한대, A[n] = 양의 무한대라고 가정한다.
int binsearch(const vector<int>& A, int x) {
    int n = A.size();
    int lo = -1, hi = n;

    // 반복문 불변식 1: lo < hi
    // 반복문 불변식 2: A[lo] < x <= A[hi]
    // (*) 불변식은 여기서 성립해야 한다.
    while (lo + 1 < hi) {
        int mid = (lo + hi) / 2;
        if (A[mid] < x)
            lo = mid;
        else
            hi = mid;
        // (**) 불변식은 여기서도 성립해야 한다.
    }
    return hi;
}
```

불변식 1,2 가 초기, 유지, 종료시에 항상 만족하고 답임을 보여, 알고리즘 정당성을 확인하자.

1. 초기 조건: while 문이 시작할 때, lo=-1, hi=n 으로 n이 0이어도 while 문을 건너뛰므로 불변식 1은
항상 성립한다. 불변식 2도 A\[-1] = 음의 무한대, A\[n] = 양의 무한대로 가정하므로 성립한다.
2. 유지 조건: while 문 내부에서 불변식을 깨뜨리지 않음을 보인다.  
불변식 1: while 문 내부이면 hi-lo >= 2 이다. 그래서 mid는 항상 두 값의 사이에 위치하게 되고,
lo 에 mid를 대입하건, hi 에 mid를 대입하건 만족한다.  
불변식 2:  
    * A\[mid] < x인 경우: 반복문 시작 전에 x <= A\[hi] 였으므로, A\[mid] < x <= A\[hi]
    * x <= A\[mid] 인 경우: 반복문 시작 전에 A\[lo] < x 였으므로, A\[lo] < x <= A\[mid]
3. 종료 시 불변식 성립을 보이고, 항상 정답임을 보인다
    * 불변식 1: while 문이 종료했으니 lo + 1 >= hi 인데, 마지막 유지조건에 의해
    lo < hi 이므로, lo + 1 = hi 이다.
    * 불변식 2: 마지막 유지조건에 의해 당연히 성립한다.
    * 우리가 원하는 결과값 i는 A\[i-1] < x <= A\[i] 인 i인데, 종료시 lo+1 = hi 이므로 
    hi 가 답이라는 사실을 쉽게 알 수 있다. 
    
### 단정문을 이용해 반복문 불변식 강제하기
불변식을 주석으로만 달아 놓을 것이 아니라 단정문으로 강제해 버리면 해당 불변식이 깨졌을 때
프로그램이 갖에 종료되기 때문에 불변식의 유지에 문제가 있다는 사실을 쉽게 알 수 있다.
단정문도 속도에 지장을 주기 때문에 엄청 많이 반복되는 반복문 안에 배치하는 것은 삼가는게 좋다.

## 귀류법
> 우리가 원하는 바와 반대되는 상황을 가정하고 논리를 전개해서 결론이 잘못됐음을 찾아내는
증명 기법을 귀류법이라고 한다.

귀류법은 대개 `어떤 선택이 항상 최선임을 증명`하고자 할 때 많이 이용된다. 우리가 선택한 답보다
좋은 답이 있다고 가정한 후에, 사실은 그런 일이 있을 수 없음을 보이면 우리가 최선의 답을 선택했음을
보일 수 있으니 말이다.

### 책장 쌓기
각 책장마다 버틸 수 있는 최대 무게 M(i)와 자신의 무게 W(i)가 주어질 때, 책장을 가장 높이 쌓을 수
있는 층 수는? 단, i번 책장 위 쌓인 모든 책장의 무게의 합은 M(i) 와 같거나 작다.

이 문제의 해답은 M(i)+W(i)가 큰 것부터 아래에 놓아야 한다는 것이다.

이 해답을 증명하기 위해 귀류법을 사용하자.
1. 먼저 우리가 증명하려는 해답의 반대를 가정하자.   
어떤 입력의 최적해를 구했는데, M(i)+W(i)가 더 큰 책장 A가 더 작은 책장 B 위에 올라간 
형태라고 가정한다.
2. 이런 가정이 발생하지 않음을 보이거나, 이런 가정이 우리 해답으로 항상 바꿀 수 있음을 보이자.  
이 문제에선 반대 가정을 우리 해답으로 항상 바꿀 수 있음을 보여, 우리의 해답으로도
항상 최적의 해를 구할 수 있음을 보일 수 있게 되는 것이다.  
B, A, X(x1, x2, ...) 이 형태로 책장이 놓여있을 때, B는 윗 칸으로 올라가니 견뎌야 할 무게가 
더 줄어들어 반드시 위에 올릴 수 있다. 문제는 M(A)가 기존 X에 W(B)까지 견딜 수 있냐는 것이다.
    * M(A) >= W(B) + X 가능한가?
    * M(A) + W(A) > M(B) + W(B)
    * M(B) >= W(A) + X, 반대 가정을 토대로 알 수 있음
    * 위 두 식을 토대로, M(A) > W(B) + X  임을 알 수 있다.

### 귀류법을 이용한 증명들
귀납법과 귀류법을 모두 이용한 증명들을 많이 볼 수 있다.
알고리즘 결과가 최선(최단 경로를 찾는다거나, 가장 높은 탑을 쌓는다거나)임을 보이기 위해
각 단계에서 최선의 선택을 함을 귀류법으로 증명하고, 각 단계에서 최선의 선택을 한다면
다음 단계에서도 최선의 선택을 할 수 있음을 귀납법으로 증명하는 것이다.

## 다른 기술들
### 비둘기집의 원리
> 비둘기집의 원리: 10마리 비둘기가 9개의 비둘기집에 모두 들어갔다면, 
2마리 이상이 들어간 비둘기집이 반드시 하나는 있게 마련이다.

### 비둘기집의 원리 예제: 동전 뒤집기
100개의 동전이 있는데 이 중 F 개는 앞면, 100-F개는 뒷면이 위로 놓여 있다. 이 동전들이 모두
앞면을 위로 하게 뒤집고 싶은데, 한 번 뒤집을 때 반드시 X개의 동전을 한꺼번에 뒤집어야 한다.
같은 동전을 두 번 이상 뒤집는 것도 상관없다. 이때 뒤집는 횟수를 최소화하려고 할때, 답의 상한은?

정답은 100이다. 동전을 한 번 뒤집을 때마다 보이는 앞면의 개수를 적는다고 하자.
어떤 답에서 동전을 101번 뒤집었다면 F까지 합쳐 102개의 숫자를 적게 되는데, 앞면의 개수는 0부터
100까지 101가지의 값만을 가질 수 있다. 비둘기집의 원리에 다라 중간에 반드시 중복이 발생할 수밖에
없으니 이 답은 최선의 답이 아니다.

보너스 문제: 100개 동전 중 앞면이 보이는 동전이 57개가 있고, 한 번에 2개의 동전만 뒤집을 
수 있다면 답은 얼마일까?  

답: 전부 앞면으로 뒤집기는 불가능하다.  
57 + 2n = 100 -> n = 43 / 2, n 은 반드시 정수여야 하므로, 만족하는 n이 존재하지 않는다.

### 비둘기집의 원리 예제: 순환 소수 찾기
분수 a/b 가 주어질 때 실수 연산을 쓰지 않고 이 분수를 소수 형태로 출력한다고 하자.  
예를 들면, 3/8 = 0.375, 4712/400 = 11.78 처럼 말이다.

```
// 분수 a/b의 소수 표현을 출력한다.
// a >= 0, b > 0 이라고 가정함
void printDecimal(int a, int b) {
    int iter = 0;
    while (a > 0) {
        // 첫 번째와 두 번째 사이에 소수점을 찍는다.
        if (iter++ == 1) cout << '.';
        cout << a / b;
        a = (a % b) * 10;
    }
}
```

만약 이 함수에 1/11 = 0.0909090909... 라는 수가 입력되면, 무한루프가 실행되는 것을 알 수 있다.
그렇다면 분수가 순환 소수라는 것을 어떻게 알 수 있을까?

비둘기집의 원리를 쓰면 문제를 쉽게 풀 수 있다. 위 코드에서 a = (a % b) * 10 부분을 보자.
a % b 의 결과는 언제나 \[0, b-1] 범위의 값을 갖는다. while 문이 b + 1 번 반복될 때까지 함수가
종료되지 않았다고 하자. a % b 의 결과는 b 가지의 결과만 가질 수 있으니 결과가 중복되는 경우가
반드시 존재하고, 같은 결과가 첫 번째로 등장했을 때부터 두 번째 등장할 때까지가 무한히 순환되는
순환 소수임을 알 수 있다.

### 구성적 증명
구성적 증명(constructive proof)은 흔히 우리가 원하는 어떤 답이 존재한다는 사실을 증명하기 위해 
사용된다. 답이 존재한다는 사실을 논증하는 것이 지금까지 다룬 방식이라면, 구성적 증명은 
`답의 실제 예`를 들거나 `답을 만드는 방법`을 실제로 제시하는 증명이다.

예를 들어 하늘을 나는 교통 수단을 만들 수 있다는 주장을 증명하려 한다고 하자.
비구성적 증명은 양력의 법칙, 지구의 공기 밀도 등을 하나하나 열거해가며 이러한 가정 하에 교통
수단이 하늘을 날 수 있음을 보이려 할 것이다. 반대로 구성적 증명은 비행기를 만들어서 보여 주거나,
비행기 만드는 법이 적힌 설명서를 건네는 것이다.

결국, 구성적 증명의 내용은 사실상 알고리즘인 경우가 많다.

### 구성적 증명 예제: 안정적 결혼 문제
n명의 남자, 여자가 미팅을 한다고 하자. 각각 자신이 원하는 상대방 우선순위를 정하고,
시간이 되어 적절히 모두 짝이 되었다고 하자. 그런데 짝이 아닌 사람들끼리 자신 파트너보다 서로를
선호한다는 사실을 알게 되었다.  
이런 일이 일어나지 않도록 짝을 지어줄 수 있는 방법이 항상 있을까? 아니면 불가능한 경우가 있을까?

위의 `안정적 결혼 문제`라고 부르는 이 문제는 구성적 증명으로 해결되는 대표적 문제이다.
답의 존재성을 보이는 대신 `답을 만드는 알고리즘을 제시`함으로써 `답이 존재함`을 보였다.

1. 처음 여자들이 모두 자신이 가장 선호하는 남자한테 프로포즈 한다. 남자가 그중 제일 마음에 드는
여자를 고르면 나머지는 퇴짜를 맞고 제 자리로 간다.
2. 퇴짜를 맞은 여자들은 (상대에게 짝이 있는지 없는지는 관계 없이) 다음으로 마음에 드는 남자한테
프로포즈를 한다. 남자들은 현재 자기 짝보다 더 마음에 든다면, 바꿀 수 있고 지금 파트너는 퇴짜를 당한다.
3. 더 프로포즈할 여자가 없을 때까지 2번을 반복한다.

이 알고리즘이 우리가 원하는 답을 구할 수 있음을 보이려면 알고리즘이 `항상 종료한다`는 것과,
`모든 사람이 짝을 찾는다`는 것, 그리고 결과적으로 이뤄진 짝들이 항상 `안정적`임을 증명해야 한다.

* 종료 증명: 각 여자는 퇴짜 맞을 때마다 우선순위를 낮춰 프로포즈한다. 따라서 각 여자는 최대 n명의
남자들에게 순서대로 프로포즈하고, 이후에 더이상 프로포즈할 남자가 없으므로, 반드시 종료된다.
* 모든 사람들이 짝을 찾는지 증명: 프로포즈 받은 남자는 그중 한 사람을 반드시 선택하고, 더 우선순위
가 높은 여성이 프로포즈해야만 짝을 바꾸므로 한 번이라도 프로포즈 받은 남자는 항상 짝이 있다.
귀류법을 적용해서, 남녀 한 사람씩 짝이 없다고 가정하자. 여자는 우선순위가 높은 순서대로 몯
한 번식 프로포즈하기 때문에, 이 남자한테도 한 번은 프로포즈했어야 했고, 남자는 프로포즈를
받아들였어야 했다. 따라서 짝을 찾지 못하는 사람은 있을 수 없다.
* 짝들의 안정성: 역시 귀류법으로 증명한다. 이 과정의 결과로 짝을 지었는데 짝이 아닌 두 남녀가
서로 자신의 짝보다 상대방을 더 선호한다고 가정하자. 여자는 지금 자신의 짝 이전에 그 남자에게
반드시 프로포즈했어야 한다. 그런데 이 남자와 짝이 되지 않았다는 말은 더 마음에 드는 여자에게
프로포즈 받아 수락했다는 뜻이다. 남자는 더 맘에 드는 여자가 나타났을 때만 짝을 바꾸므로, 프로포즈
받았던 여자보다 맘에 들지 않는 여자와 최종적으로 짝이 되는 일은 없다. 따라서 이 가정의 상황은 
존재하지 않는다.