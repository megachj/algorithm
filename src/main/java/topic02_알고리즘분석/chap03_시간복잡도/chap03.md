## 도입
프로그램의 시간은 `반복문이 지배한다.`

알고리즘의 수행 시간은 매우 종류가 다양하지만 크게 몇 가지 분류로 나눌 수 있다. 
* 상수 시간 알고리즘: O(1)
* 선형 이하 시간 알고리즘: O(lgN)
* 선형 시간 알고리즘: O(N)
* 다항 시간 알고리즘: O(N^p), p는 1이상
* 지수 시간 알고리즘: O(2^n) 이상, O(n!) 등

## 시간 복잡도
> 시간 복잡도(time complexity)란 알고리즘의 수행 시간 기준으로, 알고리즘이 실행되는 동안
> 수행하는 `기본적인 연산의 수`를 `입력의 크기에 대한 함수`로 표현한 것이다.

기본적인 연산은 더 작게 쪼갤 수 없는 최소 크기의 연산이다.
다음은 기본적인 연산이라고 볼 수 있다.
* 두 부호 있는 32비트 정수의 사칙연산
* 두 실수형 변수의 대소 비교
* 한 변수에 다른 변수 대입하기

반면 다음과 같은 연산들은 반복문을 포함하기 때문에 기본적인 연산이 아니다.
* 정수 배열 정렬하기
* 두 문자열이 서로 같은지 확인하기
* 입력된 수 소인수 분해하기

### 입력 종류에 따른 수행 시간 변화
입력의 크기가 수행 시간을 결정하는 유일한 척도는 아니다.
예를 들어 선형 탐색이 있을 때, 찾고자 하는 값이 배열의 위치에 따라 달라진다.
그래서 최선/최악의 경우와 평균적인 경우에 대한 수행 시간을 각각 따로 계산한다.
* 최선 수행 시간: 찾으려는 원소가 맨 앞에 있을 때, 수행 횟수 1번
* 최악 수행 시간: 찾으려는 원소가 없을 때, 수행 횟수 N번
* 평균적인 수행 시간: 존재할 수 있는 모든 입력의 등장 확률이 같다고 가정할때,
반환 값의 기대치는 대략 N/2 이 되고, 평균적인 수행 횟수는 N/2 이 된다.

이 세 개의 기준중 최악의 수행 시간 혹은 수행 시간 기대치를 대개 사용한다.
많은 경우 이 두 기준은 거의 같다. 퀵 정렬은 최악은 O(N^2), 기대치는 O(NlgN)으로 다르다.
그 외 랜덤화 알고리즘들에서도 다른 경우가 있다.

### 점근적 시간 표기: O 표기
> O 표기법(Big-O Notation)은 간단히 말해 주어진 함수에서 가장 빨리 증가하는 항만을 남긴 채 나머지를 다 버리는 표기법이다. 

```
// 입력이 N, M 2개인 경우 O 표기법
// 3번 처럼 어느 항이 더 빠르게 증가하는지 모르면 해당하는 항을 모두 적는다.
(1) 2^N * M = O(2^N * M)
(2) 3N^2 * M + 64NM = O(N^2 * M)
(3) N^2 * M + NlgM + N * M^2 = O(N^2 * M + N * M^2)
(4) 42 = O(1)
```

### O 표기법의 의미
> O 표기법은 대략적으로 함수의 상한을 나타낸다는데 그 의미가 있다.

```
N에 대한 함수 f(N)이 주어질 때, f(N) = O(g(N)) 이라고 쓰는 것은 다음과 같은 의미이다.

아주 큰 N0와 C(N0, C>0)를 적절히 선택하면 N0 <= N인 모든 N에 대해,
|f(N)| <= C * |g(N)| 이 참이 되도록 할 수 있다.

// 예제
N^2 + 100N + 1 = O(N^2) 이라고 쓸 수 있다.
왜냐하면 N0 = 1000, C = 2 라고 하면 위 조건이 항상 성립한다는 것을 알 수 있기 때문이다.
```

O 표기법이 수행 시간의 상한을 나타낸다는 사실을 통해 알고리즘의 최악의 수행 시간을 알아냈다고
착각하는 일이 흔히 있다. 하지만 O 표기법은 각 경우의 수행 시간을 간단히 나타내는 표기법일 뿐,
특별히 최악의 수행 시간과 관련이 있는 것은 아니다.

예를 들어 퀵 정렬의 최악의 수행 시간을 분석하면 최고차항이 N^2 임을 알 수 있고,
따라서 퀵 정렬의 최악의 시간 복잡도는 O(N^2)이다. 그러나 평균 수행 시간을 분석하면 최고차항이
NlgN이고, 따라서 퀵 정렬의 평균 시간 복잡도는 최악과 달리 O(NlgN)이 된다.

## 수행 시간 어림짐작하기
### 주먹구구 법칙
프로그램의 동작 속도에 영향을 끼치는 요소는 입력 크기, 시간 복잡도 말고도 많다.
CPU 클럭 속도, 1클럭마다 수행할 수 있는 CPU 명령어 수, 프로그램의 메모리 접근 패턴, OS, 
컴파일러 버전 등등. 그러나 보통 시간 복잡도, 입력 크기가 가장 중요하고, 이에 따라 시간 초과가
날 지를 예상해볼 수 있다.

프로그래밍 대회에서 보통 사용하는 주먹구구 법칙은 다음과 같다.

```
입력의 크기를 시간 복잡도에 대입해서 얻은 반복문 수행 횟수에 대해, 1초당 반복문 수행 횟수가
1억(10^8)을 넘어가면 시간 제한을 초과할 가능성이 있다.
```

### 주먹구구 법칙은 주먹구구일 뿐이다
주먹구구 법칙은 대략적인 예상 방법이어서 맹신해서는 안 된다. 이 기준보다 느리지만 시간 안에
수행되는 프로그램도 있고, 가끔은 이 기준보다 빠르지만 시간 안에 수행되지 않는 프로그램도 있기 때문이다.

시간 복잡도 외에도 다른 요소들을 참조해 시간 안에 수행될지를 판단해야 한다.
* 시간 복잡도가 프로그램의 실제 수행 속도를 반영하지 못하는 경우:  
O 표기법은 최고차항 이외의 항들은 모두 지워 버리고, 최고차항 계수도 무시한다.
그래서 실제로 프로그램 반복문 수는 이 계산의 수배가 될 수 있다.
* 반복문의 내부가 복잡한 경우:  
반복문 내부가 복잡하고, 시간이 많이 걸리는 연산(실수 연산, 파일 입출력 등)을 많이 사용할 경우에는
이 가정보다 시간이 오래 걸릴 수밖에 없다. 반대로 내부가 간단하면 주먹구구 가정보다 빨리 수행될 것이다.
* 메모리 사용 패턴이 복잡한 경우:  
현대 CPU는 메인 메모리 자료를 캐시 메모리로 옮겨온 뒤 처리한다. 캐시로 자료를 가져올 때 인접한
자료들을 같이 가져오므로, 인접한 자료들을 연속해서 사용하는 프로그램은 캐시를 잘 사용하게 된다.
이런 차이는 시간 복잡도에는 아무 영향을 미치지 않지만 실제 수행 속도는 훨씬 빨라지게 된다.
* 언어와 컴파일러의 차이:  
주먹구구 법칙은 최적화 옵션을 켠 현대 C++ 컴파일러를 기준으로 한다. 만약 최적화 옵션이 꺼져
있거나, 그보다 느린 언어를 사용한다면 수행 시간이 더 걸릴 수밖에 없다.
* 컴퓨터 사양이 좋지 않은 경우:  
CPU, 메모리 등 사양에 따라 주먹구구 법칙은 달라진다. 

## 계산 복잡도 클래스: P, NP, NP-완비
시간 복잡도는 알고리즘의 특성이지 문제의 특성이 아니다. 한 문제를 푸는 두 가지 이상의 알고리즘이
있을 수 있고, 이들의 시간 복잡도는 각각 다를 수 있다. 여기서 `각 문제에 대해 얼마나 빠른 알고리즘이
존재하는지를 기준`으로 **문제를 분류하고 각 분류의 특성을 연구**하는 학문이 있다.  
바로 이론 컴퓨터 과학의 중요한 분야인 `계산 복잡도 이론`이다.

### 문제의 특성 공부하기
> 계산 복잡도 이론에서 문제의 난이도는 해당 문제를 해결하는 빠른 알고리즘이 있느냐를 나타낸다.  
> 빠른 알고리즘이란 다항 시간 알고리즘이나 그보다 빠른 알고리즘들만 `빠르다`라고 한다.  
> 다항 시간 알고리즘이 존재하는 문제들의 집합을 P 문제라고 한다.  

빠른 알고리즘이 있는 문제는 계산적으로 쉽고, 빠른 알고리즘이 없는 문제는 계산적으로 어렵다고 말한다.
알고리즘 유도 과정이 아무리 길고 구현이 천만 줄이라도, 수행 시간만 빠르다면 그 문제는 쉬운 문제이다.

다음 두 문제를 비교해보자.
* 정렬 문제: 주어진 N개의 정수를 정렬한 결과는 무엇인가?
* 부분 집합 합(subset sum) 문제: N개의 수가 있을 때 이 중 몇 개를 골라내서 그들의 합이 S가 되도록
할 수 있는가?

위의 정렬 문제의 알고리즘은 O(N^2), O(NlgN) 등 수 없이 존재하므로, 정렬 문제는 P 문제이다.
P 문제처럼 같은 성질을 갖는 문제들을 모아놓은 집합을 계산 복잡도 클래스(complexity class)라고 부른다.
엄청나게 다양하고 많은 복잡도 클래스가 있지만 그중 P 문제, NP 문제 이 두 클래스가 가장 중요하다.

P(polynomial), NP(non-polynomial) 인데, NP 문제는 다항 시간 알고리즘이 존재하지 않는 문제들의
집합이라고 착각하면 안 된다. 아래에서 NP 문제의 정의를 확인하자.

### 난이도의 함정
P가 다항 시간에 풀 수 있는 문제면, NP는 당연히 풀 수 없는 문제여야 하는데 왜 정의가 그게 아닐까?
주목해야할 것은, 어떤 문제를 다항 시간에 풀 수 있음을 증명하기란 쉽지만, 풀 수 없음을 보이기란
어렵다는 점이다. 위의 부분 집합 합 문제의 다항 시간 알고리즘은 아직 아무도 찾아내지 못했다.
하지만 그렇다고 해서 그런 알고리즘이 없다고 증명할 방법도 현재까지는 없다.  
**즉, 다항 시간 알고리즘이 존재하는 문제와 존재하지 않는 문제로 문제들을 구분하기란 어렵다.**

계산 복잡도에서 말하는 `어려운 문제`들은 다음과 같이 정의된다.
* 정말 어려운 문제를 잘 골라서 이것을 어려운 문제의 기준으로 삼는다.
* 그리고 앞으로 기준 문제만큼 어렵거나 그보다 어려운 문제들, 즉 `기준 이상으로 어려운 문제들`만을
어렵다고 부른다.

위 정의가 그럴듯 하지만, 이 기준으로 문제들을 분류하려면 난관에 부딪힌다. 주어진 문제가 기준 이상으로
어려운지 판정하기가 쉽지 않기 때문이다. 문제 A가 문제 B 이상으로 어렵다고 말하려면, A를 푸는 가장
빠른 알고리즘이 B를 푸는 가장 빠른 알고리즘 이상의 시간이 걸려야 한다. 그런데 대부분 우리는 문제를
푸는 가장 빠른 알고리즘이 무엇이지 모르고, 현재 알고 있는게 가장 빠른 알고리즘이라는 법도 없다.

계산 복잡도 이론에서는 두 문제의 난이도를 비교하기 위해 `환산(reduction)`이라는 기법을 이용한다.
환산이란 한 문제를 다른 문제로 바꿔 푸는 기법이다. B의 입력을 적절히 변형해 A의 입력으로 바꾸는
환산 알고리즘이 존재한다고 하자. 이때 A를 푸는 가장 빠른 알고리즘을 가져오면, 이것을 환산 알고리즘과
결합해 B를 푸는 알고리즘을 만들 수 있다. 환산 알고리즘이 무시할 수 있을 정도로 빠르다고 가정하면 
결합된 알고리즘은 A를 푸는 가장 빠른 알고리즘과 같은 시간이 걸린다. 결국 B를 푸는 가장 빠른 알고리즘은
앞에서 결합된 알고리즘과 같거나 더 빠를 테니, 결국 B를 푸는 가장 빠른 알고리즘은 A를 푸는 가장 빠른
알고리즘과 같거나 더 빠를 수 밖에 없다. 결국 앞에서 정의한 대로, 이 경우 A가 B 이상으로 어렵다는 것을 알게 된다.

요약하면, 문제 A, B가 있고, A는 가장 빠른 알고리즘이 있다고 하자. B를 A로 환산하는 빠른 알고리즘이
있다면 B는 최소 A 만큼 빠르다는 것이다. 이 말은 바꿔말하면, A는 B이상 으로 어렵다는 것이다. 

예를들어, 주어진 배열을 정렬하는 문제와 최소치 찾는 문제의 난이도를 비교해보자.
최소치를 찾는 문제는 오름차순으로 정렬한 후 맨 앞 값을 취하면 되므로 정렬 문제로 환산할 수 있다. 
이 말은 최소치 문제는 최소 정렬 문제 만큼 빠르다는 것이고, 바꿔 말하면 정렬 문제가 최소치 문제
이상으로 어렵다고 말할 수 있다. 
자세히 보면, 정렬 문제는 가장 빠른 알고리즘이 O(NlgN) 이므로, 최소치 문제는 O(NlgN) 과 같거나 
빠르다는 것이다. 당연히 최소치 문제는 0 부터 N까지 한 번씩 조회하면 되므로 O(N)이다.  

### NP 문제, NP 난해 문제
앞에서 문제들끼리의 난이도 비교를 할 수 있었다. 이제 어려운 문제의 기준 문제를 정해야 한다.
이때 어려운 문제의 기준이 되는 것이 바로 SAT 문제(satisfiability problem)이다.

> SAT 문제란, N개의 불린 값 변수로 구성된 `논리식을 참`으로 만드는 변수 값들의 조합을 찾는 문제이다.

```
// 예제) 불린 값 변수 a, b, c 에 대해 아래 논리식을 참으로 만드는 조합을 찾아라.
((a||b||!c)&&(!c||!a)&&((!a&&b)||(b&&!c)))&&(!b||!a&&!c))
```

이 문제를 왜 어려운 문제의 기준으로 삼는 걸까? 왜냐하면 SAT 문제는 모든 NP 문제 이상으로 어렵다는
것이다. 즉 모든 NP 문제들을 SAT 문제로 환산(reduction)할 수 있다는 말이다.

그렇다면 NP 문제는 어떤 문제인가?
> NP 문제란, 답이 주어졌을 때 이것이 정답인지를 다항 시간 내에 확인할 수 있는 문제를 의미한다.

예를 들어 부분 집합 합 문제는 NP 문제이다. 답이 부분집합인지, 또 합이 S인지 다항 시간에 쉽게
확인할 수 있기 때문이다. 그리고 모든 `P 문제들도 당연히 답을 다항시간내 확인할 수 있으므로 NP 문제에
포함`된다.

SAT가 모든 NP 문제 이상으로 어렵다는 말은 SAT를 다항 시간에 풀 수 있으면 NP 문제들도 전부 자동으로
다항 시간에 풀 수 있다는 얘기이다. 이런 속성을 갖는 집합을 `NP-난해(NP-Hard) 문제`라고 한다.
NP-난해 문제들은 아주 어려워서 아직 아무도 다항 시간에 푸는 방법을 발견하지 못했다. 

NP-난해 문제이면서 NP인 문제들을 NP-완비(NP-Complete) 문제라고 한다. 
즉 답이 주어졌을 때 다항시간에 확인할 수 있고, 다른 NP 문제들이 해당 문제로 환원될 수 있는 문제를
말한다. NP-완비 문제는 생각보다 자주 만날 수 있다. 당장 부분 집합 합 문제 또한 NP-완비 문제 중 하나이다.

### P=NP?
밀레니엄 7대 수학 난제로, P=NP 문제는 P와 NP가 같은지를 확인하는 문제이다. 
* NP-난해 중 하나를 다항 시간에 푼다면, NP에 속한 모든 문제를 다항 시간에 풀 수 있다.
이 경우에 P=NP 임을 보이게 된다.
* 반대로, NP 문제 중 하나를 골라 P에 포함되어 있지 않음을 다시 말해 다항 시간 알고리즘이 존재하지
않음을 보이면 P!=NP 임을 보이게 된다.

### 요약
계산 복잡도 이론에서는 문제들을 알고리즘의 빠름으로 구분한다.
* P 문제: 다항 시간 알고리즘이 존재하는 문제
* NP 문제: 답이 주어졌을 때 이것이 정답인지를 다항 시간 내에 확인할 수 있는 문제
  * P 는 NP에 포함된다.
* NP-난해 문제: 모든 NP 문제들에 대해 환산될 수 있는 문제  
NP-난해가 다항 시간에 풀리면 모든 NP 문제들도 다항 시간에 풀리게 된다.
* NP-완비 문제: NP 문제이며, NP-난해인 문제