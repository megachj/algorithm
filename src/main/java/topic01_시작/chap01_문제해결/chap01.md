## 문제 해결 과정
> 1. 문제를 읽고 이해한다.
> 2. 문제를 익숙한 용어로 재정의한다.
> 3. 어떻게 해결할지 계획을 세운다.
> 4. 계획을 검증한다.
> 5. 프로그램으로 구현한다.
> 6. 어떻게 풀었는지 돌아보고, 개선할 방법이 있는지 찾아본다.

### 1: 문제를 읽고 이해하기
문제 설명을 공격적으로 읽으며 문제가 원하는 바를 완전히 이해하는 과정이 필요하다.
문제의 궁극적인 목적을 옳게 이해하더라도 사소한 제약 조건을 잘못 이해하면 풀 수 없는 문제들이 많다.

### 2: 재정의와 추상화
추상화란 현실 세계의 개념을 우리가 다루기 쉬운 수학적 / 전산학적 개념으로 옮겨 표현하는 과정이다.

### 3: 계획 세우기
문제를 어떤 방식으로 해결할지 결정하고, 사용할 알고리즘과 자료구조를 선택한다.

### 4: 계획 검증하기
설계한 알고리즘이 모든 경우에 요구 조건을 정확히 수행하는지를 증명하고, 수행 시간과 사용 메모리가 문제의 제한 내에 들어가는지 확인해야 한다.

### 5: 구현하기
기발한 알고리즘을 고안했더라도 제대로 구현하지 못하거나, 비효율적이면 프로그램이 제대로 동작하지 않는다. 

### 6: 회고하기
문제를 풀면서 배운 것을 정리하지 않으면, 잊어버리기 마련이다.
또 같은 문제를 어떻게 더 효율적으로 풀 수 있을까 하고 회고하는 과정이 없다면, 발전은 멈춘다. 문제를 풀 때마다 `코드와 함께 자신의 경험`을 `기록`으로 남기자.

## 문제 해결 전략
문제 해결 전략에서 가장 강조할 것은 `문제와 답의 구조에 대한 직관`의 중요성이다.  
직관은 문제의 해결 알고리즘이 대략적으로 어떤 형태를 가질지를 짐작할 수 있게 해준다.

문제를 보았을때 직관적으로 해결 전략이 떠오르지 않은 경우에는 체계적인 접근이 필요하다.  
아래는 체계적인 접근을 위한 질문들이다.

### 비슷한 문제를 풀어본 적이 있던가?
기존에 접했던 문제중에 비슷한 문제가 있는지 생각해본다.
보통 문제는 변형이 되기 때문에, 기존 문제에 대한 원리를 완전히 이해하고 변형할 수 있어야 한다.

예로 최단 경로라는 문제에서 아래처럼 변형될 수 있다.  
최단 경로 문제는 철도 위의 두 도시를 잇는 가장 짧은 경로를 찾는 문제이다.
* 한 도시를 두 번 방문하지 않으며 가장 긴 경로를 찾는 문제
* 기차를 네 번 이하로 갈아타면서 가장 짧은 경로를 찾는 문제
* 역 간 운행 거리 중 가장 긴 구간이 가장 짧은 경로를 찾는 문제
* 역 간 운행 거리 중 가장 짧은 구간이 가장 긴 경로를 찾는 문제
* 가장 긴 구간과 가장 짧은 구간의 길이 차이가 가장 적은 경로를 찾는 문제

위 문제들 중에선 최단 경로를 응용해서 풀 수 있는것도 있고, 그럴 수 없는 것도 있다.
즉, 최단 경로문제를 완벽히 이해, 응용할 줄 알아야 하며, 비슷한 문제를 많이 풀어보며 경험을
해봐야 한다.

이에 해당하는 책의 연습문제는 아래이다.
* 합친 LIS (ID: JLIS)
* 신호 라우팅 (ID: ROUTING)
* 음주 운전 단속 (ID: DRUNKEN)
* 선거 공약 (ID: PROMISE)

### 단순한 방법에서 시작할 수 있을까?
시간, 공간 복잡도를 생각하지 않고, 가장 단순한 알고리즘을 먼저 만들어보는 것이다.  
그리고 점차 효율적으로 바꾸는 것이다. 효율적인 자료 구조, 중복 계산 제거 등의 최적화를 통해서 말이다.

이에 해당하는 책의 연습문제는 아래이다.
* 쿼드 트리 뒤집기 (ID: QUADTREE)
* 모든 동적 계획법 연습 문제

### 내가 문제를 푸는 과정을 수식화할 수 있을까?
단순한 방법에서 시작해 풀 수 없고, 번뜩이는 영감이 필요한 문제도 있다. 이럴 땐 `손으로 여러 간단한 입력을 직접 풀어보는 것`이다. 자신이 이렇게 직접 풀이해보며 나온 해결 과정을 공식화해서 답을 만드는 알고리즘을 만들 수 있는 경우도 많고, 그렇지 못하더라도 이 과정에서 알고리즘이 어떤 점을 고려해야 하는지를 알 수 있다.

이에 해당하는 책의 연습문제는 아래이다.
* Quantization (ID: QUANTIZE)
* 두니발 박사의 탈옥 (ID: NUMB3RS)
* 실험 데이터 복구하기 (ID: RESTORE)
* 출전 순서 정하기 (ID: MATCHORDER)
* 마법의 약 (ID: POTION)
* 함정 설치 (ID: TRAPCARD)

### 문제를 단순화할 수 없을까?
주어진 문제의 좀더 쉬운 변형판을 먼저 풀어보는 것도 좋은 방법이다.
쉽게 변형하는 방법은 여러가지가 있다. 제약 조건을 없애거나, 계산해야 하는 변수 수를 줄이거나,
다차원 문제를 1차원으로 줄여서 표현할 수도 있다.

이에 해당하는 책의 연습문제는 아래이다.
* 비대칭 타일링 (ID: ASYMTILING)
* 드래곤 커브 (ID: DRAGON)
* 도시락 데우기 (ID: LUNCHBOX)
* 어린이날 (ID: CHILDRENDAY)
* 근거리 네트워크 (ID: LAN)

### 그림으로 그려볼 수 있을까?
많은 사람들의 사고 체계는 숫자의 나열보다 기하학적 도형을 더 직관적으로 받아들인다.
따라서 문제에 관련된 그림을 그려보는 것도 좋은 방법이다. 문제를 해결할 결정적인 직관을
얻을 수 있는 경우가 많다.

이에 해당하는 책의 연습문제는 아래이다.
* 문자열 합치기 (ID: STRJOIN)
* 너드인가, 너드가 아닌가? (ID: NERDS)
* 너드인가, 너드가 아닌가? 2 (ID: NERD2)

### 수식으로 표현할 수 있을까?
평문으로 쓰여 있는 문제를 수식으로 표현하는 것도 도움이 되는 경우가 있다.
수식을 전개하거나 축약하는 등의 순수한 수학적 조작이 문제 해결에 도움을 줄 수 있기 때문이다.

이에 해당하는 책의 연습문제는 아래이다.
* 수강 철회 (ID: WITHDRAWAL)

### 문제를 분해할 수 있을까?
문제에 주어진 복잡한 조건을 더 단순한 형태를 갖는 조건의 집합으로 분해한다.
한 개의 복잡한 조건보다 여러 개의 단순한 조건이 다루기 쉽기 때문이다.
그리고 여러 조건을 논리 관계들을 연결해 전체 조건에 대한 답을 이끌어낼 수 있다.

### 뒤에서부터 생각해서 문제를 풀 수 있을까?
문제에 내재된 순서를 바꾸는 것도 도움되는 경우가 있다. 
예를 들어 사다리 게임에서 N 명의 사람이 있고, 1개의 당첨이 있다고 할때, 당첨인 사람을 구할땐 역으로 당첨에서 사다리를 타면 된다.
즉, 어떤 문제들에선 A에서 B로 가는 방법을 찾기란 어렵지만, B에서 A로 가는 방법을 찾기는 쉽다.

이에 해당하는 책의 연습문제는 아래이다.
* 삽입 정렬 뒤집기 (ID: INSERTION)
* 감시 카메라 설치 (ID: GALLERY)
* Sorting Game (ID: SORTGAME)

### 순서를 강제할 수 있을까?
순서가 없는 문제에 순서를 강제해서 문제를 푸는 방법도 있다. 순서를 강제하면 답을 찾을때, 중복되는 답을 피할 수 있다. 그래서 순서 강제 기법은 경우의 수를 셀 때 보통 유용한 경우가 많다. 특정 조건을 만족하는 답들의 수를 세는 문제는 흔한데, 이때 까다로운 것은 한 가지 답이 중복되서 셀 수 있다는 점이다.

이에 해당하는 책의 연습문제는 아래이다.
* 게임판 덮기 (ID: BOARDCOVER)
* 폴리오미노 (ID: POLY)
* 웨브바짐 (ID: ZIMBABWE)

### 특정 형태의 답만을 고려할 수 있을까?
순서를 강제하는 기법의 연장선으로 정규화(canonicalization) 기법이 있다. 정규화란 우리가 고려해야 할 답들 중 형태가 다르지만 결과적으로는 똑같은 것들을 그룹으로 묶은 뒤, 각 그룹의 대표들만을 고려하는 방법이다.

정규화 기법은 유용하지만 사용해야 할 정규화 기법이 문제마다 매우 달라 경험을 통하지 않으면 깨닫기 쉽지 않다.

이에 해당하는 책의 연습문제는 아래이다.
* 소풍 (ID: PICNIC)
* 단어 제한 끝말잇기 (ID: WORDCHAIN)