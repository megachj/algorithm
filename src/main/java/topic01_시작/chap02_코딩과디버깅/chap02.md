## 좋은 코드를 짜기 위한 원칙
좋은 코드를 짜기 위해 특히 중요하게 적용되는 원칙들과 예외는 아래와 같다.
* 간결한 코드 작성하기
* 적극적으로 코드 재사용하기: 매우 중요하지만, 대회나 시험에선 시간제한이 있어
실무처럼 이상적으로 하기엔 무리가 있다.
* 표준 라이브러리 공부하기
* 항상 같은 형태로 프로그램 작성하기
* 일관적이고 명료한 명명법 사용하기
* 모든 자료를 정규화해서 저장하기: 정규화는 프로그램이 자료를 입력받거나
계산하자마자 곧장 이루어져야 한다. 이상적으로는 클래스 생성자에서
정규화를 수행하거나, 외부에서 자료를 입력받자마자 정규화를 수행하는게 좋다.
    * 시간: 항상 협정 세계시간(UTC)로 표시한 시간과, 시간대를 저장
    * 문자열: 외부에서 읽어들이자마자 UTF-16 이나 UTF-8 인코딩으로 변환
* 코드와 데이터를 분리하기: 데이터는 컬렉션이나, enum 등을 활용해서
따로 관리하는게 좋다.

## 자주 하는 실수
아래는 프로그래밍 대회에서 흔히 저지르는 대표적인 실수이다.
* 산술 오버플로
* 배열 범위 밖 원소에 접근: 직접 메모리 주소에 값을 넣는 C/C++에 해당함.
* 일관되지 않은 범위 표현 방식 사용하기: 결론적으로 컬렉션을 사용할 때
닫힌 구간(closed interval), 열린 구간(open interval), 반 열린 구간(half-open interval)
이 있는데, 프로그래밍 언어가 사용하는 범위 표현으로 사용한다. 자바는
반 열린 구간을 사용하고, 반 열린 구간은 아래처럼 편한 점이 많다.
    * 공집합을 표현하기 쉽다. [a, a)
    * 두 구간이 연속해 있는지 알기 쉽다. [a, b), [c, d) 이면,
    b = c 또는 a = d 이면 두 구간은 연속이다.
    * 구간의 크기를 쉽게 알 수 있다. [a, b) 의 크기는 b-a 이다.
* Off-by-one 오류: 계산 큰 줄기는 맞지만, 하나가 모자라거나 하나가
많아서 틀리는 코드 오류들을 가리킨다. 보통 반복문에서 처음이나 끝을
포함, 불포함해서 발생한다. 최소 입력이 주어졌을 때의 코드 검증을
염두해두며 프로그램을 짜도록 하자.
* 컴파일러가 잡지 못하는 상수 오타
* 스택 오버플로
* 다차원 배열 인덱스 순서 바꿔 쓰기
* 잘못된 비교 함수 작성
* 최소, 최대 예외 잘못 다루기
* 연산자 우선순위 잘못 쓰기
* 너무 느린 입출력 방식 선택: 입출력의 양이 많을때 어떤 입출력 방식을
선택하는지가 프로그램의 정답 여부를 충분히 바꿀 수 있다. 
보통 입출력 수가 1만 개를 넘어가면 긴장하는 것이 좋다.
* 변수 초기화 문제: 프로그램 한 번만 실행하고, 한 번에 여러 입력에 대해
답을 처리하는 경우에, 한 번의 입력마다 변수를 초기화 해주도록 작성해야 한다.
그렇지 않으면 2번째 케이스부터 값이 이상해질 수 있기 때문이다.

## 디버깅과 테스팅
### 디버깅에 관하여
프로그래밍 대회나 테스트를 볼 땐 디버거 없이 프로그램의 버그를 찾아내는 연습을
할 필요가 있다. 코드가 복잡해지면 디버거 없이 눈으로 프로그램을 검증하긴 어렵지만,
이 경우에는 애초에 코드를 복잡하게 짰다는 것이 문제이다.
잘 분리된 기능적인 코드는 눈만으로도 검증하기가 비교적 쉽다.

디버거를 사용하는 대신 다음과 같은 단계를 밟으면 좋다.
* 작은 입력에 대해 제대로 실행되나 확인하기
* 단정문(assertion) 쓰기: 메소드의 인자들이 범위 안에 들어 있는지, 값들을
제대로 입력받았는지 assertion 으로 검사할 수 있고, 내부 상태를 검증할 수 있어
유용하다.
* 프로그램의 계산 중간 결과를 출력하기: 로직이 중간중간 맞는지 체크해볼 수 있다.

### 테스트에 관하여
많은 경우 예제 입출력 외에도 몇 가지 입력을 만들어 넣어보면 오답률을 줄일 수 있다.

프로그램을 테스트할 때 유용하게 사용할 수 있는 기법으로 스캐폴딩(scaffolding)이 
있다. 스캐폴딩은 코드의 정당성 확인이나, 반례를 찾는데 특히 유용하게 쓰인다.

예를 들어, 오답이지만, 예제 모든 입력은 정답이고 소스에서도 잘못된 점을 발견하지
못하는 경우에 임의의 작은 입력을 자동으로 생성해 프로그램 돌리고, 그 답안을 검증
하는 프로그램을 짜면 큰 도움이 된다.
실제 대회에선 느리지만 단순한 알고리즘을 하나 사용해서, 자동화된 입력에 대해 검증
해볼 수 있다.

## 변수 범위의 이해
### 산술 오버플로
수학에선 어떤 변수 n에 담을 수 있는 숫자에 제한이 없다. 그러나 컴퓨터의
모든 변수에는 담을 수 있는 크기가 제한되어 있다. 그래서 수학적으로는 정당한
알고리즘이 프로그램으로 구현시 예상과 달리 동작할 수 있다.
프로그램 전체에 연산되는 수의 범위를 잘 파악하고 적절한 자료형을 사용해야 한다.

### 너무 큰 무한대 값
프로그램을 짜다 보면 무한대에 해당하는 큰 값을 이용하는 것이 편리할 때가 있다.

이때 무한대 값을 잘못 설정하면 프로그램 오류가 날 수 있다.
예를 들어 32비트 부호 있는 정수를 변수로 사용할 때 무한대 값을 2^31 - 1 값으로
사용한다면, 무한대 값을 연산할 때 오버플로가 발생할 수 있다.

따라서 무한대 값을 선택할 때는 이 무한대 값들이 서로 더해지거나 곱해지는 경우가
없는지 잘 살펴보고 이럴 때도 오버플로가 나지 않을 크기의 값을 선택하는 것이 좋다.

예를 들면, `987,654,321`은 설정하기 좋은 수이다. 2^30 에 가까운 큰 값이면서, 
서로 더해지더라도 32비트 부호 있는 정수에 오버플로를 내지 않고, 
1,000,000,000 보다 오타가 났는지 눈으로 확인하기도 용이하기 때문이다.

### 자료형의 프로모션
사칙연산이나 대소 비교 등 이항 연산자들은 두 개의 피연산자를 받는다.
이 피연산자 자료형이 다르거나 자료형의 범위가 작은 경우 컴파잉러들은 이들을
같은 자료형으로 변환해 계산하는데, 이를 프로모션이라고 한다.

이 프로모션은 알기 어려운 버그를 만드는 주역이 되기도 한다.
프로모션 과정은 언어마다 다르므로 주의해야 한다.

## 실수 자료형의 이해
### 실수와 근사 값
무리수, 순환소수처럼 현실의 수는 무한의 영역이지만, 메모리는 유한하다.
그래서 근사 값을 실수로 저장하게 되고, 정확하지 않을 수 있기 때문에 실수는
훨씬 다루기 까다롭다.

정수 수식은 몇 번을 계산해도 같은 값이 반환되지만, 실수 계산은 어떤 순서로
계산하는지, 컴파일러 최적화, 심지어는 중간 로그 메시지를 출력하는지 여부에
따라서 그 답이 달라질 수 있다. 이런 현상에 당황하지 않기 위해 컴퓨터가
사용하는 실수 표현 방식과 그 장단점을 이해해야 한다.

### IEEE 754 표준
가장 많은 컴퓨터/컴파일러에서 사용되는 실수 표기 방식은 IEEE 754 표준 이라고
불린다. 이것의 가장 큰 특징은 다음과 같다.
* 이진수로 실수를 표기
* 부동 소수점(floating-point) 표기
* 무한대, 비정규 수(subnormal number), NaN(Not a Number: 숫자 아님) 등의
특수한 값이 존재

실제 IEEE 754는 실수 연산에 관한 규정, 오버플로와 언더플로 처리, 반올림에 
관한 규정 등을 모두 포함하는 방대한 표준이다.

### 실수의 이진법 표기
정수 이진법 표기와 동일하다.  
정수부는 2^0, 2^1, ... 와 같은 방식으로 커지고, 소수부는 2^-1, 2^-2, ...
방식으로 작아진다.

### 부동 소수점 표기
부동 소수점 방식은 소수점 위치가 바뀌기 때문에 실수를 표현할 때 주로 사용하며, 고정 소수점
방식보다 넓은 범위의 수를 표현할 수 있다.

```
// 실수의 구성
// m: 가수(mantissa), r: 밑, e: 지수(exponent)
m * r^e

// 예
57.23 * 10^1 에서 m(가수)는 57.23, r(밑수)는 10, e(지수)는 1이 된다.
```

위의 실수를 표현하는데, 부동 소수점 표기 방법을 아래와 같이 정의해두었다.

| 자료형 | 부호 비트 | 지수 비트 | 가수 비트 | 지수 범위 | 지수 bias | 유효자릿수 (십진수) |
| --- | --- | --- | --- | --- | --- | --- |
| 32비트 실수형 | 1 | 8 | 23 | -2^7 + 2 ~ 2^7 -1 | 2^7 -1 | 6 |
| 64비트 실수형 | 1 | 11 | 52 | -2^10 + 2 ~ 2^10 -1 | 2^10 -1 | 15 |
| 80비트 실수형 | 1 | 15 | 64 | -2^14 + 2 ~ 2^14 -1 | 2^14 -1 | 18 |

지수 비트가 n 비트 이면, 지수 표현 가지 수는 2^n 개 인데, 지수 범위가 2개씩 부족하게 해놨다.  
음수의 가장 작은 2개 수를 뺐는데, 이들은 8비트일 때 127 bias 적용시 11111111(-128), 00000000(-127) 이다.
비트로만 봤을땐 가장 작은 수(00000000), 가장 큰 수(11111111) 를 제외하는 것이다.

실수를 부동소수점 실수형 변수로 바꿀때 아래 두 단계를 거친다.
1. 실수를 1.xxx 로 정규화하고, 가수(m) 으로 .xxx 를 설정한다.
    * 이때 0이 아닌 수는 항상 1이 있으므로, 1은 제외하고 가수 비트에 저장이 된다.
2. 지수를 지수 비트에 쓸 때 bias 를 적용한다.
    
```
// 예제) 2진수 10110.11011 을 32 비트 실수형의 부동 소수점으로 나타내라.
// 1. 정규화
1.011011011 * 2^4
m = 011011011
e = 4

// 2. 지수 비트 bias 적용
4 + 127 = 131

// 답
( 부동 소수점 ) 0 10000011 00000000000000011011011

// 예제) 2진수 0.000101 를 32 비트 실수형 부동 소수점으로 나타내라.
// 1. 정규화
1.01 * 2^(-4)
m = 01
e = -4

// 2. 지수 비트 bias 적용
-4 + 127 = 123

// 답
( 부동 소수점 ) 0 01111011 00000000000000000000001
```

bias 의 의미는 n bit 가 있을때, 음수 포함 표현할 수 있는 수의 범위를 비트 값 순서로 정렬하는 것이다.
예를 들면 bias 를 하지 않으면 4 bit일 때 0을 표현시 0000 이고, -6 은 1010 이다.
즉 비트를 2진수로 보면 0보다 -6이 더 크다. 
이를 7 bias 하면, 0은 0111, -6 은 0111 이다. 

결론 32비트 실수형은 부정확한 경우가 많아, 64비트 실수형으로 사용하자.

### 실수 비교하기
앞에서 살펴본 것처럼, 실수는 근사값이다. 표현 범위 이내에 2진수가 정확히 맞아 떨어지면 정확하겠지만 10진수 실수로
정확히 표현되던게 2진수 실수로는 근사값으로 표현되는게 많다. 예를 들어 1/10, 3/10 모두 10진수로는 정확히 표현이
되지만 2진수로는 근사값으로 표현된다.

위와 같은 이유로 두 실수 값이 같은지를 비교할 때는 항상 어느 정도의 오차를 염두에 두고, 
두 값의 차이가 오차 한도보다 작은 경우 두 값이 같다고 판단해야 한다.
```
boolean isEqual(double a, double b) {
    return fabs(a - b) < 1e-10;
}
```

그런데, 두 실수가 같다라는 기준인 오차 한도의 크기를 정하는데 신중해야 한다.
예를 들면 10^20 / x * x 와 10^20 은 같은 값인데, x가 50이하일 땐 오차가 
1e-10 보다 커진다. 즉 오차 한도를 1e-10 으로 정하면, `같은 값인데도 오차 한도를
벗어나 같지 않다`라고 결과가 나오게 된다.

그래서 오차 한도 값은 신중히 결정해야 한다. 같다고 판단해야 하는 값들은 오차가
좀 있더라도 같게 판단할 수 있을만큼 커야 하고, 다르다고 판단해야 할 값들은
오차가 좀 있더라도 다르게 판단할 수 있을만큼 작아야 하기 때문이다.

이 문제를 해결하기 위해 크게 두 가지 방법이 있다.

#### 하나: 비교할 실수의 크기들에 비례한 오차 한도를 정한다
두개의 수식 f(x), g(x) 가 있고, f(x) = g(x) 라고 하자.

첫 번째는 같다고 판단해야 할 큰 값 두 개를 비교할 경우이다.  
이론적으로는 f(x1)=y, g(x1)=y 가 되어야 하는데, 실제로 나온 실수 값은
f(x1)=a, g(x1)=b라고 할때, 같다고 판단해야할 오차범위 |a-b|의 최대 값을 생각하고, 
|a-b|보다 큰 오차 한도 값을 사용한다.
|a-b|의 최대 값을 가늠하는 한 가지 방법은 이 변수들이 가질 수 있는 최대 값의
1e-10 ~ 1e-12 정도를 취하는 것이다. 

두 번째는 다르게 판단해야 할 작은 값 두 개를 비교할 경우이다.  
f(x1)=y1, g(x1)=y2 가 되어야 하는데, 실제로 나온 실수 값은
f(x1)=a, g(x1)=b라고 할때, 다르다고 판단해야할 오차범위 |a-b|의 최소 값을 생각하고,
|a-b|보다 작은 오차 한도 값을 사용한다.

결국, 첫 번째를 생각해 |a-b| 의 하한을 세우고, 두 번째를 생각해 |a-b|의 상한선을 
세운다. 하한과 상한 사이의 값을 선택하면 된다.

오차 한도를 적절히 선택하는 기술은 많은 경험과 실패가 있어야 늘지만, 잘 계산했을
경우 안정적으로 원하는 답을 찾을 수 있다. 만약 이런 계산을 할 수 없거나
하기 싫은 경우엔, 좀더 일반적인 다음 방법을 이용하자.

#### 둘: 상대 오차를 이용한다
문제 입력으로 한 자리가 주어질지 서른 자리가 주어질지 알 수 없을 때는
미리 오차 한도를 정할 수 없다. 이런 경우는 비교하는 숫자들의 크기에
비례하여 오차를 정하는 방식을 사용해야 한다. 두 수의 크기에 비해 그
차이가 작다면 두 수가 같다고 판정하는 식이다.

```
// 상대 오차
relativeError(a, b) = |a - b| / max(|a|, |b|)
```

이런 상대 오차를 이용해 비교를 하는 메소드를 다음과 같이 작성할 수 있다.
```
// a, b의 오차가 더 큰 수의 0.000001% 이하이면 true 를 리턴
boolean relativeEqual(double a, double b) {
    return fabs(a - b) <= 1e-8 * max(fabs(a), fabs(b));
}
```

위 방식은 큰 수를 비교할 때는 별 문제가 없지만, 매우 작은 숫자들을
비교할 땐 문제가 될 수 있다.
예를 들면 relativeError(0, x) = x/x = 1 이게 되어 x가 0.00000000001로
충분히 작아도 거짓이 나오게 됩니다.

이런 문제를 해결하기 위해, 두 수의 절대 차이가 매우 작을 경우에 
두수가 같다고 판단할 필요가 있다. 이때 절대 오차 확인은 0에 매우 
가까운 수들을 처리하기 위해 추가한 것인만큼, 허용 오차를 좀더 작게
잡을 필요가 있다.
```
// 절대 오차, 상대 오차를 모두 이용한 실수 비교
boolean doubleEqual(double a, double b) {
    double diff = fabs(a - b);
    
    // 절대 오차가 허용 범위 안일 경우 무조건 true 리턴
    if (diff < 1e-10) return true;

    // 상대 오차를 사용
    return diff <= 1e-8 * max(fabs(a), fabs(b));
}
```

### 대소 비교
두 수가 같은지 판단하는 것이 아닌 대소를 판단할 때도 연산 오차가
발목을 잡을 수 있다. a=b가 되어야 할 두 수의 계산에서, 오차 때문에
a가 약간 더 작은 값으로 계산되었다고 해보자. 그러면 a<b 는 원래
거짓이어야 했는데 참이 된다. 반대로 a에 약간 큰 값이 얻어졌을 경우
a <= b 는 참 대신 거짓이 된다. 
이 문제를 피하려면 비교할 때 `항상 두 값이 같은 경우를 먼저 확인`하고
처리해야 한다.

### 정확한 사칙연산
실수 변수라고 해서 그 값이 항상 정확하지 않은 것은 아니다.

가수부 안에 들어가는 `정수` 들은 정확하게 저장할 수 있다.
64 비트 실수형 가수부는 52비트 이므로, 절대 값이 +-2^52 보다 작은
모든 정수들은 항상 정확하게 표현할 수 있다.
같은 원리로 3.5, 43783/16384 와 같이 분모가 2의 거듭제곱인 유리수들도
정확하게 표현할 수 있다.

가끔 추가적인 자료 구조를 도입해 정확한 사칙연산을 구현할 수 있는
경우도 있다. 프로그램에서 사용하는 수가 모두 유리수라면, 실수 변수 대신
분모 분자를 각각 관리하는 유리수 클래스를 만들어 정확한 사칙연산을
할 수도 있다.

또 표현할 수 있는 숫자들 범위가 넓지만 항상 십진수로 정확히 표현할
수 있다면 큰 정수 변수에서 소숫점 위치를 옮길 수 있는 십진수 클래스
(자바의 BigDecimal)를 사용할 수도 있다.

### 코드의 수치적 안정성 파악하기
어떤 프로그램이 수치적으로 안정적(numerically stable)이라는 말은
프로그램의 실행 과정에서 발생하는 오차가 더 커지지 않는다는 말이다.
예를 들어 실행 중간 연산 오차는 0.00000001 만큼 차이났는데, 마지막
연산 결과는 17293 만큼 차이난다면 이 프로그램은 아주 작은 오차를
부풀린 셈이고 이를 수치적으로 불안정하다고 한다.
반면 수치적으로 안정적인 프로그램은 중간에 작은 오차가 있더라도 마지막
결과또한 작은 오차만을 갖는다.

아래 예를 살펴보자.
```
// 문제) 주어진 다각형을 포함할 수 있는 가장 작은 원의 반지름 크기R 구하기
// canCover(r): 반지름 r 인 원으로 다각형을 덮을 수 있는지 판단하는 메소드
// canCover 메소드에 실수 연산 오차가 존재함.
double minRadiusCover() {
    double minRadius = 0, maxRadius = 10;
    
    // 반복문 불변식: canCover(maxRadius) = true
    while (maxRadius - minRadius > 1e-10) {
        // 중간 반지름 길이 계산시 오차 발생 가능
        double mid = (minRadius + maxRadius) / 2;
        if (canCover(mid))
            maxRadius = mid;
        else
            minRadius = mid;
    }
    return maxRadius;
}
```
위 예에서 주어진 다각형을 덮을 수 있는 제일 작은 원 반지름이 R일 때,
canCover(R)이 연산 오차에 따라 가끔 거짓을 반환하거나, 
canCover(R*0.999999999)가 가끔 참을 반환할 수 있다.
즉 연산 중간결과는 오차가 작은 오차가 존재한다.
하지만 전체 메소드 minRadiusCover() 는 canCover()를 1e-10 이하가 
될 때까지 반복한다. 그리고 아무리 실수 연산 오차가 있다해도 canCover()
는 R보다 아주 조금 큰 어떤 값에서 참을 반환하게 되므로, minRadiusCover()
의 답은 정답과 아주 조금밖에 차이 나지 않을 것이다.

여기서 만약 r의 후보가 정해진 경우를 생각해보자.
만약 후보가 {1, 2, 3, 4, 10}이고 답이 3이라고 하자. canCover(3) 이 
오차로 인해 거짓을 반환해 버리면, 엄청나게 차이나는 4가 답으로 반환된다. 

이렇듯, 수치적인 안정성은 알고리즘의 특징에 따라 좌우되고, 
이를 판단하는 데는 많은 시행 착오와 경험이 필요하다.

### 경고
컴퓨터에서 실수 표현은 매우 복잡하고 방대한 주제이다. 
여기서 다룬 내용은 프로그래밍 대회나 현업에서 일반적으로 만날 수 있는
주제만을 다룬다. 대표적으로 IEEE 754가 표현할 수 있는 특수 수(NaN)에
대해 전혀 다루지 않는다. 즉 이 내용들 말고도 실수에 대한 내용은 매우 많다.

### 실수 연산 아예 하지 않기
앞에서 본 것처럼 실수 연산은 오류를 발생시킬 가능성이 매우 높아
주의 깊게 코드를 작성해야 한다.
하지만 의외로 많은 경우에 문제를 변형해 실수 연산을 없앨 수 있다.

다음은 변형의 대표적인 몇 가지 예이다.
* 곱셈과 나눗셈 순서 바꾸기: 세 정수 a / b * c 를 계산해야 하는데,
결과가 항상 정수라는 것을 알고 있다면 (a * c) / b 로 바꿀 수 있다.
* 양변 제곱하기: xy 좌표에서 두 점 사이의 거리 r 이 필요할 때, r^2
을 이용할 수 있다.
* 실수 좌표를 써야 하는 기하 문제에서 좌표계를 가로 세로로 정수배 늘리면
정수만을 이용해 문제를 풀 수도 있다.